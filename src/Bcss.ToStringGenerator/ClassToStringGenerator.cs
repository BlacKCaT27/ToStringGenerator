using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Bcss.ToStringGenerator
{
    /// <summary>
    /// Generates source code to override the "ToString()" method for classes by analyzing the target source code using Roslyn.
    /// </summary>
    [Generator]
    public class ClassToStringGenerator : IIncrementalGenerator
    {
        private const string HidePrivateMembersConfigurationKey = "build_property.ToStringGeneratorHidePrivateMembers";
        private const string RedactedValueConfigurationKey = "build_property.ToStringGeneratorRedactedValue";
        
        private const string GenerateToStringAttributeName = "Bcss.ToStringGenerator.Attributes.GenerateToStringAttribute";

        /// <summary>
        /// Initializes the incremental source generator.
        /// </summary>
        /// <param name="context">The context for the incremental generator initialization, providing mechanisms to register actions or interact with the compilation process.</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            GenerateMarkerAttributes(context);
            var configOptions = GetToStringGeneratorConfigOptionsProvider(context);
            var typeDeclarations = GetTypeDeclarationsProvider(context);
            var combined = CombineProviders(typeDeclarations, configOptions);
            
            context.RegisterSourceOutput(combined,
                (spc, tuple) =>
                {
                    Execute(spc, tuple.ConfigOptions!, tuple.Types);
                });
        }

        private static void GenerateMarkerAttributes(IncrementalGeneratorInitializationContext context)
        {
            // Register the attribute source
            context.RegisterPostInitializationOutput(i =>
            {
                const string generateToStringAttribute = @"
#if !TO_STRING_GENERATOR_EXCLUDE_GENERATED_ATTRIBUTES
// <auto-generated>
namespace Bcss.ToStringGenerator.Attributes
{
    /// <summary>
    /// <p>Generates a ToString() method for the marked class or struct at compile time.</p>
    /// <p>By default, the string will be in the format:</p>
    /// <code>[className: member1Name = member1value, member2Name = member2value, ... ]</code>
    /// <br />
    /// <p>Collection members that implement IEnumerable or IEnumerableT will have each element written in square brackets, comma separated.</p>
    /// <code>[className: collectionMember = [value1, value2, value3] ... ]</code>
    /// <br />
    /// <p>Dictionary members that implement IDictionary or DictionaryT1, T2 will have each key-value pair written in brackets, comma separated.</p>
    /// <code>[className: dictionaryMember = [{key1 = value1}, {key2 = value2}] ... ]</code>
    /// <br />
    /// </summary>
    /// <remarks>
    /// <p>This attribute will be automatically loaded at compile time by the ToString source generator. You should not need to reference
    /// the project containing this attribute directly.</p>
    /// <br />
    /// <p>If your project exposes internal classes via [InternalsVisibleTo] and you reference the source generator package in multiple
    /// projects in one solution, you may end up with duplicate class definitions due to multiple generators being invoked. If this occurs,
    /// define the following constant in your projects .csproj file, then add a direct reference to the <c>Bcss.ToStringGenerator.Attributes</c>
    /// nuget package.</p>
    /// <br />
    /// <code><DefineConstants>TO_STRING_GENERATOR_EXCLUDE_GENERATED_ATTRIBUTES</DefineConstants></code>
    /// <br />
    /// </remarks>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class GenerateToStringAttribute : Attribute
    {
    }
}
#endif";
                i.AddSource("GenerateToStringAttribute.g.cs", generateToStringAttribute);
            });
            
            context.RegisterPostInitializationOutput(i =>
            {
                const string generateToStringAttribute = @"
#if !TO_STRING_GENERATOR_EXCLUDE_GENERATED_ATTRIBUTES
// <auto-generated>
namespace Bcss.ToStringGenerator.Attributes
{
    /// <summary>
    /// An attribute for marking a field or property as sensitive. Sensitive members will not have their value output
    /// in the generated ToString() method. Instead, the provided `maskingValue` string is written. If no value is given,
    /// a default value is used.
    /// </summary>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
    public class SensitiveDataAttribute : Attribute
    {
        /// <summary>
        /// Gets the masking value to be used for the member marked with this attribute.
        /// </summary>
        public string MaskingValue { get; }

        /// <summary>
        /// Masks the value of the field or property that is marked with this attribute when
        /// generating a ToString() method.
        /// </summary>
        /// <remarks>
        /// <p>This attribute will be automatically loaded at compile time by the ToString source generator. You should not need to reference
        /// the project containing this attribute directly.</p>
        /// <br />
        /// <p>If your project exposes internal classes via [InternalsVisibleTo] and you reference the source generator package in multiple
        /// projects in one solution, you may end up with duplicate class definitions due to multiple generators being invoked. If this occurs,
        /// define the following constant in your projects .csproj file, then add a direct reference to the <c>Bcss.ToStringGenerator.Attributes</c>
        /// nuget package.</p>
        /// <br />
        /// <code><DefineConstants>TO_STRING_GENERATOR_EXCLUDE_GENERATED_ATTRIBUTES</DefineConstants></code>
        /// <br />
        /// </remarks>
        /// <param name=""maskingValue"">Sets the value that will be used in the ToString output instead of the members actual value.</param>
        public SensitiveDataAttribute(string maskingValue = ""[REDACTED]"")
        {
            MaskingValue = maskingValue;
        }
    }
}
#endif";
                i.AddSource("SensitiveDataAttribute.g.cs", generateToStringAttribute);
            });
        }

        private static IncrementalValueProvider<ToStringGeneratorConfigOptions> GetToStringGeneratorConfigOptionsProvider(
            IncrementalGeneratorInitializationContext context)
        {
            return context.AnalyzerConfigOptionsProvider
                .Select((provider, _) =>
                {
                    ToStringGeneratorConfigOptions config = new();
                    if (provider.GlobalOptions.TryGetValue(RedactedValueConfigurationKey, out var redactionValue))
                    {
                        config.RedactionValue = redactionValue;
                    }
                    
                    if (provider.GlobalOptions.TryGetValue(HidePrivateMembersConfigurationKey, out var hidePrivateMembers))
                    {
                        bool didParse = bool.TryParse(hidePrivateMembers, out bool parsedBool);
                        if (didParse)
                        {
                            config.HidePrivateMembers = parsedBool;
                        }
                    }

                    return config;
                })
                .WithTrackingName(TrackingNames.ReadConfig);
        }

        private static IncrementalValuesProvider<ClassSymbolData?> GetTypeDeclarationsProvider(IncrementalGeneratorInitializationContext context)
        {
            return context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    GenerateToStringAttributeName,
                    predicate: (node, _) => node is ClassDeclarationSyntax,
                    transform: (ctx, _) => GetTypeWithGenerateToStringAttribute(ctx))
                .WithTrackingName(TrackingNames.InitialExtraction);
        }

        private static IncrementalValueProvider<(ImmutableArray<ClassSymbolData?> Types, ToStringGeneratorConfigOptions ConfigOptions)> CombineProviders(
            IncrementalValuesProvider<ClassSymbolData?> typeDeclarationsProvider,
            IncrementalValueProvider<ToStringGeneratorConfigOptions> configOptionsProvider)
        {
            return typeDeclarationsProvider
                .Collect()
                .Combine(configOptionsProvider)
                .WithTrackingName(TrackingNames.CombineProviders);
        }

        private static void Execute(SourceProductionContext context, ToStringGeneratorConfigOptions toStringGeneratorConfigOptions, ImmutableArray<ClassSymbolData?> classSymbolData)
        {
            foreach (var classData in classSymbolData)
            {
                if (classData == null) continue;

                var sourceCode = ToStringGeneratorHelper.GenerateToStringMethod(classData.Value, toStringGeneratorConfigOptions);
                var fileName = $"{classData.Value.ClassName}.ToString.g.cs";

                context.CancellationToken.ThrowIfCancellationRequested();
                context.AddSource(fileName, sourceCode);
            }
        }
        
        private static ClassSymbolData? GetTypeWithGenerateToStringAttribute(GeneratorAttributeSyntaxContext ctx)
        {
            var targetNode = ctx.Attributes
                .Any(attr => attr.AttributeClass?.ToDisplayString() == GenerateToStringAttributeName)
                ? ctx.TargetNode
                : null;

            if (targetNode is null) return null;

            var typeSymbol = ctx.SemanticModel.GetDeclaredSymbol(targetNode);
            if (typeSymbol is null) return null;

            string containingNamespace = typeSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;
            string classAccessibility = GetAccessibility(typeSymbol);
            string className = typeSymbol.Name;
            var memberSymbols = GetMemberSymbols(typeSymbol);
            var members = GetMemberSymbolData(memberSymbols, ctx.SemanticModel.Compilation);

            return new ClassSymbolData(containingNamespace, classAccessibility, className, members);
        }

        private static List<MemberSymbolData> GetMemberSymbolData(IEnumerable<ISymbol> memberSymbols, Compilation compilation)
        {
            var result = new List<MemberSymbolData>();

            foreach (var memberSymbol in memberSymbols)
            {
                var memberAccessibility = GetAccessibility(memberSymbol);
                var memberType = GetMemberType(memberSymbol);
                var (isSensitive, mask) = IsSensitive(memberSymbol);
                
                result.Add(new MemberSymbolData(
                    memberSymbol.Name,
                    memberAccessibility,
                    IsDictionary(memberType, compilation),
                    IsEnumerable(memberType, compilation),
                    IsNullableType(memberSymbol),
                    isSensitive,
                    memberSymbol.IsStatic,
                    mask));
            }
            
            return result;
        }
        
        private static ITypeSymbol GetMemberType(ISymbol member)
        {
            return member switch
            {
                IPropertySymbol property => property.Type,
                IFieldSymbol field => field.Type,
                _ => throw new ArgumentException($"Unexpected member type: {member.GetType()}")
            };
        }

        private static string GetAccessibility(ISymbol typeSymbol)
        {
            return typeSymbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Protected => "protected",
                Accessibility.ProtectedOrInternal => "protected internal",
                Accessibility.ProtectedAndInternal => "private protected",
                _ => "private"
            };
        }

        private static (bool, string?) IsSensitive(ISymbol symbol)
        {
            var attributeSyntax = symbol.DeclaringSyntaxReferences
                .SelectMany(r => r.GetSyntax().DescendantNodes())
                .OfType<AttributeSyntax>()
                .FirstOrDefault(a => a.Name.ToString().Contains("SensitiveData"));

            if (attributeSyntax is null)
            {
                return (false, null);
            }

            // If the attribute has no arguments, the default value is used.
            if (attributeSyntax.ArgumentList?.Arguments.Count > 0)
            {
                var arg = attributeSyntax.ArgumentList.Arguments[0];
                if (arg.Expression is LiteralExpressionSyntax literal)
                {
                    return (true, literal.Token.ValueText);
                }
            }

            return (true, null);
        }
        
        private static IEnumerable<ISymbol> GetMemberSymbols(ISymbol typeSymbol)
        {
            List<ISymbol> result = [];
            ImmutableArray<ISymbol> membersForType = ((INamespaceOrTypeSymbol)typeSymbol).GetMembers();
            foreach (var symbol in membersForType)
            {
                if (symbol.Kind == SymbolKind.Property)
                {
                    result.Add(symbol);
                    continue;
                }

                if (symbol is IFieldSymbol { AssociatedSymbol: null, Kind: SymbolKind.Field })
                {
                    result.Add(symbol);
                }
            }

            return result;
        }
        
        private static bool IsDictionary(ITypeSymbol type, Compilation compilation)
        {
            // Check for both generic and non-generic IEnumerable
            var dictionaryType = compilation.GetTypeByMetadataName("System.Collections.Generic.Dictionary`2");
            var dictionaryInterface = compilation.GetTypeByMetadataName("System.Collections.IDictionary");
            
            if (dictionaryType == null || dictionaryInterface == null) 
                return false;

            // Check if the type implements IEnumerable<T> or IEnumerable
            return type.AllInterfaces.Any(i => 
                SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, dictionaryType) ||
                SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, dictionaryInterface));
        }

        private static bool IsEnumerable(ITypeSymbol type, Compilation compilation)
        {
            // Don't treat string as an enumerable
            if (type.SpecialType == SpecialType.System_String)
                return false;

            // Check for both generic and non-generic IEnumerable
            var genericEnumerable = compilation.GetTypeByMetadataName("System.Collections.Generic.IEnumerable`1");
            var nonGenericEnumerable = compilation.GetTypeByMetadataName("System.Collections.IEnumerable");
            
            if (genericEnumerable == null || nonGenericEnumerable == null) 
                return false;

            // Check if the type implements IEnumerable<T> or IEnumerable
            return type.AllInterfaces.Any(i => 
                SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, genericEnumerable) ||
                SymbolEqualityComparer.Default.Equals(i.OriginalDefinition, nonGenericEnumerable));
        }

        private static bool IsNullableType(ISymbol member)
        {
            var type = GetMemberType(member);

            // Check if it's a nullable value type (e.g., int?)
            if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T })
            {
                return true;
            }

            // Check if it's a reference type (all reference types are nullable in C# 9.0+ with nullable reference types enabled)
            return type.IsReferenceType && type.NullableAnnotation != NullableAnnotation.NotAnnotated;
        }
    }
}
